---
date: 2024-09-10T18:37
tags:
  - Tarea
  - Universidad
  - martes
cssclasses:
  - tarea
  - martes
author: youname
institution: Universidad TUP
course: Nombre del Curso
professor: Nombre del Profesor
---
`
 ![[logo_tup.png]]![[../../../../../../../../99 - Meta/attachments/img/Pasted image 20240910031424.png]]
# [215 FUNDAMENTOS DE INGENIERÍA DEL SOFTWARE 25-1](https://moodle.tecplayacar.edu.mx/course/view.php?id=6032 "215 FUNDAMENTOS DE INGENIERÍA DEL SOFTWARE 25-1")

## **Datos del Estudiante**

- **Nombre**: Jesus Uriel Santana Oliva
- Grado : 1 -B
- **Profesor**: [PROF.-MARCO ANTONIO ANGEL GALEANA](https://moodle.tecplayacar.edu.mx/user/view.php?id=8662&course=6032)
- **Institución**: Universidad Tecnologica Playacar
- Fecha: _martes, septiembre 10º, 2024_
###### **Actividad

> [!cite] Responder en un documento word las siguientes preguntas
¿Por qué se requiere tanto tiempo para terminar el software?
¿Por qué son tan altos los costos de desarrollo?
¿Por qué no podemos detectar todos los errores antes de entregar el software a nuestros clientes?
¿Por qué dedicamos tanto tiempo y esfuerzo a mantener los programas existentes?
¿Por qué seguimos con dificultades para medir el avance mientras se desarrolla y mantiene el software?

> [!success] Terminada
> Tarea Terminada
> 

## ¿Por qué se requiere tanto tiempo para terminar el software?

![[../../../../../../../../99 - Meta/attachments/img/Pasted image 20240910183237.png]]

El proceso de desarrollo de software es extenso por varias razones. La **complejidad del software** es uno de los principales factores, ya que los sistemas modernos contienen millones de líneas de código que interactúan entre sí, lo que requiere tiempo para entender y gestionar adecuadamente [^1]. Además, los **requisitos cambian constantemente** durante el desarrollo, ya sea por nuevas necesidades del negocio o una mejor comprensión de lo que realmente se necesita [^2]. Estos cambios no solo prolongan el tiempo, sino que complican la planificación y la ejecución.
![[Pasted image 20240910183653.png]]

Las **estimaciones iniciales son imprecisas**, lo que provoca que los tiempos de desarrollo estimados se alarguen debido a la incertidumbre que existe en las fases tempranas del proyecto
[^3]. La **coordinación entre equipos y dependencias** también juega un papel crucial, ya que coordinar a varios equipos y tareas interdependientes puede llevar más tiempo del previsto [^4]. Finalmente, el tiempo invertido en **pruebas y depuración** es considerable. 
![[Pasted image 20240910185307.png]]
	[Figura(N-1)MTL.DEV.SOFT](https://repositorio.uca.edu.ar/bitstream/123456789/522/1/metodologias-desarrollo-software.pdf) 

Los errores deben ser identificados y corregidos antes de que el software esté listo, lo cual se vuelve más complicado conforme aumenta la complejidad del sistema [^5].
	| [Otr.Ref](https://www.udocz.com/apuntes/592858/1-por-que-se-requiere-tanto-tiempo-para-terminar-el-software-el-ciclo-de-la-vid) | [M.Scrum](https://asana.com/es/resources/what-is-scrum)| [MTL.DEV.SOFT.](https://repositorio.uca.edu.ar/bitstream/123456789/522/1/metodologias-desarrollo-software.pdf)
## ¿Por qué son tan altos los costos de desarrollo?
![[Pasted image 20240910183418.png]]

El alto costo del desarrollo de software también es un tema común en la industria. El desarrollo es **intensivo en mano de obra**, y los salarios de los desarrolladores y otros profesionales involucrados representan una parte significativa del presupuesto [^6]. Además, a medida que los sistemas de software se vuelven más complejos, **el esfuerzo y la habilidad requeridos aumentan**, lo que incrementa los costos [^1]. Los **cambios frecuentes en los requisitos** también suman costos imprevistos durante el proceso de desarrollo [^2].

Otro aspecto que eleva los costos es la necesidad de realizar **pruebas exhaustivas** para garantizar la calidad del software, lo cual es costoso tanto en términos de tiempo como de recursos, especialmente en sistemas grandes [^5]. A esto se suma la necesidad de **infraestructura y herramientas**, como servidores, licencias de software y equipos especializados, que agregan costos adicionales al proyecto [^4].

## ¿Por qué no podemos detectar todos los errores antes de entregar el software a nuestros clientes?

![[../../../../../../../../99 - Meta/attachments/img/Pasted image 20240910183343.png]]

Detectar todos los errores antes de entregar el software es prácticamente imposible por varias razones. La **complejidad del software** hace que sea inviable probar todas las posibles interacciones y escenarios que podrían presentarse [^1]. Además, **las pruebas tienen limitaciones** y no pueden cubrir todos los casos de uso posibles, por lo que siempre hay áreas que no son evaluadas completamente [^5].

El **entorno de prueba controlado** es otra limitación, ya que no refleja con precisión el entorno real en el que el software será utilizado por los clientes [^3]. Muchos errores ocurren solo en **casos extremos o bordes**, lo que los hace difíciles de reproducir en un entorno de prueba [^2]. Además, los **plazos ajustados** no permiten que el software sea probado de manera tan exhaustiva como sería ideal antes de su entrega [^4].

## ¿Por qué dedicamos tanto tiempo y esfuerzo a mantener los programas existentes?
![[Pasted image 20240910183456.png]]

El mantenimiento de software es una tarea continua y exige una cantidad significativa de tiempo y esfuerzo. Los **sistemas heredados** son a menudo muy complejos, con código entrelazado que hace que los cambios sean difíciles y arriesgados [^1]. La **documentación insuficiente** también es un problema, ya que el código no siempre está documentado adecuadamente, lo que dificulta comprender su funcionamiento [^3].


Muchas veces, los sistemas tienen **dependencias ocultas** entre componentes que solo se hacen evidentes cuando se intenta realizar algún cambio [^2]. Asegurarse de que no se rompa nada más en el sistema al hacer modificaciones requiere **pruebas exhaustivas**, lo que agrega tiempo adicional al proceso [^5]. Además, la **presión por añadir nuevas funciones** hace que el mantenimiento nunca termine realmente, ya que siempre se requiere actualizar y mejorar el software [^4].

## ¿Por qué seguimos con dificultades para medir el avance mientras se desarrolla y mantiene el software?
![[Pasted image 20240910183545.png]]

Medir el avance en proyectos de software es complicado debido a la **naturaleza intangible del software**. A diferencia de los productos físicos, no es fácil ver el progreso o los resultados parciales [^1]. Cuando los **requisitos cambian** a mitad del proyecto, es difícil saber si el software está más cerca o más lejos de cumplir las expectativas finales [^2].

Las **métricas tradicionales**, como las líneas de código o los puntos de función, no reflejan el progreso real, ya que el avance es difícil de cuantificar con estas herramientas [^3]. Las **dependencias ocultas** con otras partes del sistema a menudo no se detectan hasta que los cambios se integran, lo que complica aún más el seguimiento del progreso [^4]. Además, a medida que el software evoluciona, **la complejidad del sistema aumenta**, lo que hace más difícil determinar cuán cerca estamos de finalizar el proyecto [^1].

En resumen, los desafíos en el desarrollo y mantenimiento del software radican en la complejidad de los sistemas, los constantes cambios en los requisitos, las limitaciones de las pruebas y las métricas disponibles, además de la naturaleza intangible del producto. Sin embargo, los avances en las últimas décadas han ayudado a mitigar estos problemas, aunque siguen siendo significativos.

## Referencias

[^1]: Brooks, F. P. (1987). No silver bullet: Essence and accidents of software engineering. *Computer*, 20(4), 10-19. https://doi.org/10.1109/MC.1987.1663532  
[^2]: Boehm, B. (1988). A spiral model of software development and enhancement. *Computer*, 21(5), 61-72. https://doi.org/10.1109/2.59  
[^3]: DeMarco, T. (1982). Controlling software projects: Management, measurement and estimation. Yourdon Press.  
[^4]: Parnas, D. L. (1994). Software aging. *Proceedings of the 16th International Conference on Software Engineering*, 279-287. https://doi.org/10.1109/ICSE.1994.296790  
[^5]: Pressman, R. S. (2010). Software engineering: A practitioner's approach (7th ed.). McGraw-Hill.  
[^6]: Boehm, B. W. (1981). Software engineering economics. Prentice Hall.

[^7]: Licenciatura en Sistemas y Computación, T. (n.d.). _Metodologías de desarrollo de software_. Edu.Ar. Retrieved September 11, 2024, from https://repositorio.uca.edu.ar/bitstream/123456789/522/1/metodologias-desarrollo-software.pdf?page=19
